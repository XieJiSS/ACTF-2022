# 中文wp

## Dropper

- difficulty: easy
- flag: `ACTF{dr0pp3r_1s_v3ry_int3r3st1ng_1d7a90a63039831c7fcaa53b766d5b2d!!!!!}`
- description:

The competition question sets a little simple software protection method, can you solve it?

### Writeup

- 考察点
    - upx壳+dropper+大数运算+简单的异常处理+虚函数表hook
- 如果运行不成功：
    - 根据缺失的dll库，下载对应的64位版本，放到system32目录下面
- 中文wp
    - 使用upx加壳工具脱掉壳
    - 通过dropper搜索相关含义，找到从资源区获取数据并加密的代码，如果可以找到‣， 那基本离解题更进一步
        - 没找到运行PE文件的函数交叉引用，猜测是使用了GetProcAddress，利用交叉引用找到对应地方
            - 静态分析找到，或者动态跟踪找到对应的数据，分析解密，写脚本将数据解密，生成真正的可执行文件
                - 这里还是比较简单的，就是做了个异或某个数字
    - 动态调试跟踪，可以跟踪到加密和验证的所有过程，并不复杂，这里只是加了反静态分析的方法，利用简单的除0进行异常捕捉进行虚函数表hook，使得静态分析失效
        - 可以输入flag后，对text区下断点，获得处理逻辑地址，在IDA中找到之后，设置断点，进行跟踪
            - 猜测生成的大数是如何存储的，动态调试找到存储数据的地址空间，并尝试将十六进制转换为十进制，可以看到十进制只以十六进制存储。
        - 根据IDA的string，发现BASE64的字符串表，根据交叉引用，找到真正的加密判断地址
    - 也可以使用动态调试，打开文件，运行到“flag:”，停止当前进程，然后附加到被创建的子进程，就可以动态调试被生成的子进程。
- 解密代码：

```python
import base64

res = 834572051814337070469744559761199605121805728622619480039894407167152612470842477813941120780374570205930952883661000998715107231695919001238818879944773516507366865633886966330912156402063735306303966193481658066437563587241718036562480496368592194719092339868512773222711600878782903109949779245500098606570248830570792028831133949440164219842871034275938433
res = res + 57705573952449699620072104055030025886984180500734382250587152417040141679598894
res = res - 71119332457202863671922045224905384620742912949065190274173724688764272313900465
res = res + 55079029772840138145785005601340325789675668817561045403173659223377346727295749
res = res - 14385283226689171523445844388769467232023411467394422980403729848631619308579599
res = res + 80793226935699295824618519685638809874579343342564712419235587177713165502121664
res = res // 7537302706582391238853817483600228733479333152488218477840149847189049516952787
res = res - 17867047589171477574847737912328753108849304549280205992204587760361310317983607
res = res + 55440851777679184418972581091796582321001517732868509947716453414109025036506793
res = res // 11783410410469738048283152171898507679537812634841032055361622989575562121323526
res = res - 64584540291872516627894939590684951703479643371381420434698676192916126802789388

s = ''
while res:
    s += chr(res % 128)
    res = res // 128

print(base64.b64decode(s))
```