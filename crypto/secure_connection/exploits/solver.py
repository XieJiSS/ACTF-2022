from Crypto.Cipher import AES
import base64
import tqdm
import libscrc

'''
how secure connection is built
hello
>	81 03 d9 b2 df e9 3b f9 
<	81 03 d9 b2 df e9 3b f9 
exchange initCRC

SC REQ
>	82 10 ec 36 e5 b0 69 55 d9 95 56 7e e5 de 45 07
	37 f8 7d d5 57 
exchange master IV and Secret

SC RSP
<	83 10 68 b3 de d5 b8 40 14 dc f3 fb 75 02 d9 39
	0e 34 a6 bf 63
exchange slave IV and Secret

MConfirm (taint)
>	84 10 9f 51 36 ca cd 9f 2a 53 87 39 4b 7d 0c 1c
	16 fa 58 46 05
send 16 bytes MConfirm

SConfirm (taint)
<	85 10 02 d6 e4 cd 53 5c 86 b7 ba 90 6e 57 05 5a
	8e c8 2d db b8
send 16 bytes SConfrm

MRandom
>	86 10 4b d2 09 24 f0 c3 cd 30 ba 64 a0 f1 d9 64
	69 1e fa a2 d5
send 16 bytes MRandom

SRandom (taint)
<	87 10 dd 76 51 4f 57 36 81 3a a8 c2 17 8e 7c f8
	2d 5b 6f 68 ec 
send 16 bytes SRandom

'''

# Since TK is only 3 bytes entropy, just brute for it


def bytes_xor_16(bytes1, bytes2):
    v1 = int.from_bytes(bytes1, 'big')
    v2 = int.from_bytes(bytes2, 'big')
    v3 = v1 ^ v2
    return (v3).to_bytes(16, 'big')


def secure_encrypt(key, plain):
    aes = AES.new(key=key, mode=AES.MODE_ECB)
    return aes.encrypt(plain)


def secure_confirm(key, r, p1, p2):
    return secure_encrypt(key, bytes_xor_16(secure_encrypt(key, bytes_xor_16(r, p1)), p2))


def secure_decrypt_packet(key, plain, nonce):
    aes = AES.new(key=key, mode=AES.MODE_CCM, nonce=nonce)
    return aes.decrypt(plain)


Mrandom = b"\x4b\xd2\x09\x24\xf0\xc3\xcd\x30\xba\x64\xa0\xf1\xd9\x64\x69\x1e"
# to make problem more interesting, taint some confirm value
# one can use CRC to recover them or just leave them along
Mconfirm = b"\x9f\x51\x36\xca\xcd\x9f\x2a\x53\x87\x39\x4b\x7d\x0c\x1c"  # \x16\xfa"

# like 7 minutes
# for key in tqdm.tqdm(range(0, 0x1000000, 1)):
#     key_bytes = (key).to_bytes(16, "little")
#     should_Mconfirm = secure_confirm(
#             key_bytes, Mrandom, b"\x00" * 16, b"\xff" * 16)
#     if should_Mconfirm[:14] == Mconfirm:
#         print("!!! Found numeric key !!!")
#         print("key = {}".format(key))
#         break
# !!! Found numeric key !!!
# key = 9190693


# CRC recover SRandom
Srandom1 = b"\xdd\x76\x51\x4f\x57\x36\x81\x3a\xa8\xc2\x17\x8e"
Srandom2 = b"\xf8\x2d\x5b"
initCRC_bytes = b"\xd9\xb2\xdf"
initvalue = int.from_bytes(initCRC_bytes, "little")
expected_CRC = b"\x6f\x68\xec"

# for byte in range(255):
#     Srandom = Srandom1 + chr(byte).encode('latin-1') + Srandom2
#     pdu = b"\x87\x10" + Srandom
#     crc = libscrc.hacker24(data=pdu, poly=0x00065B, init=initvalue,
#                            xorout=0x00000000, refin=True, refout=True)
#     crc_bytes = crc.to_bytes(3, "little")
#     if crc_bytes == expected_CRC:
#         print(hex(byte))
# 0x7c
Srandom = b"\xdd\x76\x51\x4f\x57\x36\x81\x3a\xa8\xc2\x17\x8e\x7c\xf8\x2d\x5b"
Secretm = b"\x56\x7e\xe5\xde\x45\x07\x37\xf8"
Secrets = b"\xf3\xfb\x75\x02\xd9\x39\x0e\x34"
# we forget IV hahaha nevermind

# prepare session key
numeric_key = 9190693
numeric_key_bytes = (numeric_key).to_bytes(16, "little")
store_key = secure_encrypt(numeric_key_bytes, Mrandom[:8] + Srandom[8:])
session_key = secure_encrypt(store_key, Secretm + Secrets)

# ... just decrypt the flag ...
# b'You got your flag: ACTF{ShORt_NUmeR1c_KEY_1s_Vuln3R4bLe_TO_e@V3sDropPEr}'
remote_counter = 7
encrypted_data = b"\xa2\x16\x25\x39\xdf\x5b\xac\x45\x95\x86\x53\x58\x12\xdb\x74\xa6\xcb\x54\x1d\xd7\x1f\x64\xec\x4d\x12\x71\x9f\x32\xa6\xde\xf8\x99\xe3\xd7\xeb\x62\xc4\x12\x77\x02\x17\x3e\xc2\x42\xbc\x32\xaa\x5e\x82\xfe\xe8\xea\x33\x5b\xc4\xad\x7d\xc8\xf2\x2e\x20\x59\xa3\x04\x19\x17\x1a\xbe\x73\xaf\xe6\x5b\xfa\xa6\xad\xa3\x2a\x15\x78\x8d\x0d\xb6\xb3\x59\xb0\xbe\x7f\xa6\xaf\x68\xcd\xe6\xe2\x4c\xa9\x5d"
plain = secure_decrypt_packet(session_key, encrypted_data, (remote_counter).to_bytes(13, 'little'))
print(plain)
print(base64.b64decode(plain))