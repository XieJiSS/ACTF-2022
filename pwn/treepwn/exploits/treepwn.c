/*
 * author: f0rm2l1n
 * stupid but clear implementation according to specification
 * https://www.cse.cuhk.edu.hk/~taoyf/course/infs4205/lec/rtree.pdf
 *
 * to introduce a vulnerability and make this a CTF challenge
 * add possible type confusion here
 */

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

#include <unistd.h>

#define INSERT (0)
#define DELETE (1)
#define EDIT (2)
#define SHOW (3)
#define QUERY (4)
#define LEAVE (5)

/*
 * Each leaf node has between 0.4 B and B data points, where B >= 3
 */
#define B (5)
#define minB (2) // 5 * 0.4 = 2

#define NODE_NAME_MAX (32)
#define NODE_COUNT_MAX (256)
#define CORD_SIZE_MAX (4096)
#define ELEM_COUNT_MAX (64)

#define ROOT_BIT_MASK 0b01
#define LEAF_BIT_MASK 0b10

#define is_root(x) (x->ntype & ROOT_BIT_MASK)
#define is_leaf(x) (x->ntype & LEAF_BIT_MASK)

char banner[] = "\n"
                "  [..                                                          \n"
                "  [..                                                          \n"
                "[.[. [.[. [...   [..       [..    [. [..  [..     [...[.. [..  \n"
                "  [..   [..    [.   [..  [.   [.. [.  [..  [..  .  [.. [..  [..\n"
                "  [..   [..   [..... [..[..... [..[.   [.. [.. [.  [.. [..  [..\n"
                "  [..   [..   [.        [.        [.. [..  [. [. [.[.. [..  [..\n"
                "   [.. [...     [....     [....   [..     [...    [...[...  [..\n"
                "                                  [..\n"
                "You can place some elements in 0 - 4096 size square\n";

char menu[] = "Choice Table\n"
              "[ 0 ] Place a element\n"
              "[ 1 ] Remove a element\n"
              "[ 2 ] Edit a element\n"
              "[ 3 ] Show a element\n"
              "[ 4 ] Query a element\n"
              "[ 5 ] Leave\n"
              "Your choice > ";

struct element
{
    char name[NODE_NAME_MAX];
    uint8_t type;
    uint16_t x;
    uint16_t y;
};

struct node
{
    int ntype;
    int count;

    /* since two points in x,y panel can decide
     * a rectange: left down node A, and right top node B
     * rect[0] - A.x,
     * rect[1] - A.y
     * rect[2] - B.x
     * rect[3] - B.y
     * uint16_t rect[4];
     */
    struct node *parent;
    void *childs[B + 1];
};

struct rtree
{
    int height;
    size_t elem_count;
    struct node *root;
};

struct rtree *gtree;

void read_buf_wrap(char *buf, uint32_t length)
{
    char tmp;
    for (uint32_t i = 0; i < length; i++)
    {
        if (read(0, &tmp, 1) < 0)
            return;
        buf[i] = tmp;
    }
}

void write_buf_wrap(char *buf, uint32_t length)
{
    for (uint32_t i = 0; i < length; i++)
    {
        if (write(1, buf + i, 1) < 0)
            return;
    }
}

static void tree_init()
{
    gtree = malloc(sizeof(struct rtree));
    memset(gtree, 0, sizeof(struct rtree));
    struct node *nptr = malloc(sizeof(struct node));
    memset(nptr, 0, sizeof(struct node));
    nptr->count = 0;
    nptr->ntype |= LEAF_BIT_MASK;
    nptr->ntype |= ROOT_BIT_MASK;
    nptr->parent = NULL;
    gtree->root = nptr;
    gtree->height = 1;
}

static void tree_clear_node(struct node *n)
{
    if (is_leaf(n))
    {
        for (int i = 0; i < n->count; i++)
        {
            struct element *e = n->childs[i];
            free(e);
        }
        free(n);
    }
    else
    {
        for (int i = 0; i < n->count; i++)
        {
            tree_clear_node(n->childs[i]);
        }
        free(n);
    }
}

static void tree_clear()
{
    // we need to delete the entire tree
    // recusively delete node
    tree_clear_node(gtree->root);
    free(gtree);
}

// declarations
static struct node *tree_choose_subtree(struct node *n, struct element *tower);
static struct node *tree_choose_branch(struct node *n, struct node *branch);
static void handle_node_overflow(struct node *n);
static void tree_insert_node(struct node *n, struct element *elem);
static void tree_delete_elem(struct node *n, struct element *elem);
static void tree_sort_leaf_node(struct node *n, bool x);
static uint16_t tree_get_MBR_perimeter(uint16_t rect[4]);
static void tree_derive_MBR_node(struct node *n, uint16_t rect[4]);
static bool is_position_in_MBR(uint16_t x, uint16_t y, uint16_t rect[4]);
static bool is_MBR_intersect_MBR(uint16_t rect1[4], uint16_t rect2[4]);
static void extend_MBR_to_contain(uint16_t rect_ext[4], uint16_t rect_be_contain[4]);
static struct node *tree_split_leaf_node(struct node *n);
static struct node *tree_split_internal_node(struct node *n);
static struct node *tree_split_node(struct node *n);
static void tree_handle_node_overflow(struct node *n);
static void tree_handle_node_underflow(struct node *n);
static struct element *tree_query_element(struct node *n, uint16_t wantx, uint16_t wanty);
static size_t tree_query_range(struct element *output[], size_t offset, struct node *n, uint16_t range[4]);

static struct node *tree_choose_subtree(struct node *n, struct element *elem)
{
    // traverse all n's subtree and return the one that owns the MBR
    // requires the minimum increase in perimeter to cover the node tower
    int min_index = 0;
    int min_MBR_added = 0x10000;

    for (int i = 0; i < n->count; i++)
    {
        struct node *child = n->childs[i];
        uint16_t original_MBR[4] = {0};
        tree_derive_MBR_node(n, original_MBR);
        uint16_t original_MBR_perimeter = tree_get_MBR_perimeter(original_MBR);

        // assume insert, update the MBR
        if (elem->x < original_MBR[0])
            original_MBR[0] = elem->x;
        if (elem->x > original_MBR[2])
            original_MBR[2] = elem->x;
        if (elem->y < original_MBR[1])
            original_MBR[1] = elem->y;
        if (elem->y > original_MBR[3])
            original_MBR[3] = elem->y;
        uint16_t update_MBR_perimeter = tree_get_MBR_perimeter(original_MBR);
        uint16_t delta_MBR_perimeter = update_MBR_perimeter - original_MBR_perimeter;
        if (delta_MBR_perimeter < min_MBR_added)
        {
            min_index = i;
            min_MBR_added = delta_MBR_perimeter;
        }
    }
    return n->childs[min_index];
}

static int get_min_MBR_added(struct node *n, struct element *elem)
{
    int min_index = 0;
    int min_MBR_added = 0x10000;

    for (int i = 0; i < n->count; i++)
    {
        struct node *child = n->childs[i];
        uint16_t original_MBR[4] = {0};
        tree_derive_MBR_node(child, original_MBR);
        uint16_t original_MBR_perimeter = tree_get_MBR_perimeter(original_MBR);

        // assume insert, update the MBR
        if (elem->x < original_MBR[0])
            original_MBR[0] = elem->x;
        if (elem->x > original_MBR[2])
            original_MBR[2] = elem->x;
        if (elem->y < original_MBR[1])
            original_MBR[1] = elem->y;
        if (elem->y > original_MBR[3])
            original_MBR[3] = elem->y;
        uint16_t update_MBR_perimeter = tree_get_MBR_perimeter(original_MBR);
        uint16_t delta_MBR_perimeter = update_MBR_perimeter - original_MBR_perimeter;
        if (delta_MBR_perimeter < min_MBR_added)
        {
            min_index = i;
            min_MBR_added = delta_MBR_perimeter;
        }
    }
    return min_MBR_added;
}

static struct node *tree_choose_branch(struct node *n, struct node *branch)
{
    int min_index = 0;
    int min_MBR_added = 0x10000;

    uint16_t branch_MBR[4] = {0};
    tree_derive_MBR_node(branch, branch_MBR);

    for (int i = 0; i < n->count; i++)
    {
        struct node *child = n->childs[i];
        uint16_t original_MBR[4] = {0};
        tree_derive_MBR_node(n, original_MBR);
        uint16_t original_MBR_perimeter = tree_get_MBR_perimeter(original_MBR);
        extend_MBR_to_contain(original_MBR, branch_MBR);
        uint16_t new_MBR_perimeter = tree_get_MBR_perimeter(original_MBR);
        uint16_t MBR_added = new_MBR_perimeter - original_MBR_perimeter;
        if (MBR_added < min_MBR_added)
        {
            min_index = i;
            min_MBR_added = MBR_added;
        }
    }
    return n->childs[min_index];
}

static void tree_insert_node(struct node *n, struct element *elem)
{
    if (is_leaf(n))
    {
        // check if this location is exists
        for (int i = 0; i < n->count; i++)
        {
            struct element *e = n->childs[i];
            if (elem->x == e->x && elem->y == e->y)
            {
                // we mask the print to make the bug finding difficulter
                // printf("Oooops, this position is already occupied\n");
                // printf("Insertion failed\n");
                return;
            }
        }

        n->childs[n->count++] = elem;
        if (n->count == B + 1)
        {
            tree_handle_node_overflow(n);
        }
        gtree->elem_count += 1;
    }
    else
    {
        // *** we intend to introduce the bug here ***
        // struct node *subtree = tree_choose_subtree(n, elem);
        // tree_insert_node(subtree, elem);
        int min_MBR_added = get_min_MBR_added(n, elem);
        for (int i = 0; i < n->count; i++)
        {
            struct node *child = n->childs[i];
            uint16_t original_MBR[4] = {0};
            tree_derive_MBR_node(child, original_MBR);
            uint16_t original_MBR_perimeter = tree_get_MBR_perimeter(original_MBR);

            // assume insert, update the MBR
            if (elem->x < original_MBR[0])
                original_MBR[0] = elem->x;
            if (elem->x > original_MBR[2])
                original_MBR[2] = elem->x;
            if (elem->y < original_MBR[1])
                original_MBR[1] = elem->y;
            if (elem->y > original_MBR[3])
                original_MBR[3] = elem->y;
            uint16_t update_MBR_perimeter = tree_get_MBR_perimeter(original_MBR);
            uint16_t delta_MBR_perimeter = update_MBR_perimeter - original_MBR_perimeter;
        
            if (delta_MBR_perimeter == min_MBR_added)
            {
                // !!! BUG
                // no break here
                // multiple insertion here
                tree_insert_node(child, elem);
            }
        }
    }
}

static void tree_insert_branch(struct node *n, struct node *branch)
{
    n->childs[n->count++] = branch;
    branch->parent = n;
    if (n->count == B + 1)
    {
        tree_handle_node_overflow(n);
    }
}

static void tree_delete_elem(struct node *n, struct element *elem)
{
    // we need to find the leaf node that contains this element
    // quite similar as query
    if (is_leaf(n))
    {
        // traverse childs to confirm
        for (int i = 0; i < n->count; i++)
        {
            struct element *eptr = n->childs[i];
            if (eptr == elem)
            {
                // we found it
                // refill leaf node childs
                for (int j = i; j < n->count - 1; j++)
                {
                    n->childs[j] = n->childs[j + 1];
                }
                n->childs[n->count - 1] = NULL;
                n->count -= 1;

                gtree->elem_count -= 1;
                free(elem);

                if (n->count < minB)
                    tree_handle_node_underflow(n);

                return;
            }
        }
    }
    else
    {
        // traverse MBR of child to confirm
        // interesting, since the underflow handling
        // in tree_delete_elem could free the n node
        // itself, we need to get a copy of the childs buffer
        int copy_count = n->count;
        struct node *copy_childs[B + 1] = {0};
        memcpy(copy_childs, n->childs, copy_count * sizeof(void *));

        for (int i = 0; i < copy_count; i++)
        {
            struct node *nptr = copy_childs[i];
            struct element *tmp = NULL;
            uint16_t rect[4] = {0};
            tree_derive_MBR_node(nptr, rect);
            if (is_position_in_MBR(elem->x, elem->y, rect))
            {
                tree_delete_elem(nptr, elem);
                // !!! BUG
                // the elem may not in this MBR
                // this break should not be here
                break;
            }
        }
    }
}

static void tree_sort_leaf_node(struct node *n, bool x)
{
    struct element *tmp;
    if (x)
    {
        for (int i = 0; i < n->count; i++)
        {
            for (int j = i; j < n->count; j++)
            {
                if (
                    ((struct element *)(n->childs[j]))->x < ((struct element *)(n->childs[i]))->x)
                {
                    tmp = n->childs[j];
                    n->childs[j] = n->childs[i];
                    n->childs[i] = tmp;
                }
            }
        }
    }
    else
    {
        for (int i = 0; i < n->count; i++)
        {
            for (int j = i; j < n->count; j++)
            {
                if (
                    ((struct element *)(n->childs[j]))->y < ((struct element *)(n->childs[i]))->y)
                {
                    tmp = n->childs[j];
                    n->childs[j] = n->childs[i];
                    n->childs[i] = tmp;
                }
            }
        }
    }
}

static void tree_sort_internal_node(struct node *n, bool x, bool leftordown)
{
    struct node *tmp;
    if (x)
    {
        for (int i = 0; i < n->count; i++)
        {
            for (int j = i; j < n->count; j++)
            {
                uint16_t rect1[4] = {0};
                uint16_t rect2[4] = {0};

                tree_derive_MBR_node(n->childs[i], rect1);
                tree_derive_MBR_node(n->childs[j], rect2);

                // left boundaries on x-dimension
                if (leftordown)
                {
                    if (rect1[0] > rect2[0])
                    {
                        tmp = n->childs[j];
                        n->childs[j] = n->childs[i];
                        n->childs[i] = tmp;
                    }
                }
                else
                {
                    if (rect1[2] > rect2[2])
                    {
                        tmp = n->childs[j];
                        n->childs[j] = n->childs[i];
                        n->childs[i] = tmp;
                    }
                }
            }
        }
    }
    else
    {
        for (int i = 0; i < n->count; i++)
        {
            for (int j = i; j < n->count; j++)
            {
                uint16_t rect1[4] = {0};
                uint16_t rect2[4] = {0};

                tree_derive_MBR_node(n->childs[i], rect1);
                tree_derive_MBR_node(n->childs[j], rect2);

                // left boundaries on x-dimension
                if (leftordown)
                {
                    if (rect1[1] > rect2[1])
                    {
                        tmp = n->childs[j];
                        n->childs[j] = n->childs[i];
                        n->childs[i] = tmp;
                    }
                }
                else
                {
                    if (rect1[3] > rect2[3])
                    {
                        tmp = n->childs[j];
                        n->childs[j] = n->childs[i];
                        n->childs[i] = tmp;
                    }
                }
            }
        }
    }
}

static uint16_t tree_get_MBR_perimeter(uint16_t rect[4])
{
    uint16_t ret = 0;
    ret += 2 * (rect[2] - rect[0]);
    ret += 2 * (rect[3] - rect[1]);
    return ret;
}

static void tree_derive_MBR_node(struct node *n, uint16_t rect[4])
{
    if (is_leaf(n))
    {
        uint16_t max_x, max_y;
        uint16_t min_x, min_y;
        // init
        max_x = min_x = ((struct element *)(n->childs[0]))->x;
        max_y = min_y = ((struct element *)(n->childs[0]))->y;
        // loop
        for (int i = 0; i < n->count; i++)
        {
            struct element *elem = n->childs[i];
            uint16_t node_x = elem->x;
            uint16_t node_y = elem->y;

            if (node_x < min_x)
                min_x = node_x;
            if (node_x > max_x)
                max_x = node_x;
            if (node_y < min_y)
                min_y = node_y;
            if (node_y > max_y)
                max_y = node_y;
        }

        // left down node
        rect[0] = min_x;
        rect[1] = min_y;
        // right top node
        rect[2] = max_x;
        rect[3] = max_y;
        return;
    }
    else
    {
        // internal node is a little complex, need recursive
        uint16_t rects[4 * (B + 1)] = {0};
        for (int i = 0; i < n->count; i++)
        {
            tree_derive_MBR_node(n->childs[i], (uint16_t *)rects + 4 * i);
        }
        uint16_t max_x, max_y;
        uint16_t min_x, min_y;
        min_x = rects[0];
        min_y = rects[1];
        max_x = rects[2];
        max_y = rects[3];
        for (int i = 0; i < n->count; i++)
        {
            uint16_t maybe_min_x = rects[0 + 4 * i];
            uint16_t maybe_min_y = rects[1 + 4 * i];
            uint16_t maybe_max_x = rects[2 + 4 * i];
            uint16_t maybe_max_y = rects[3 + 4 * i];
            if (maybe_min_x < min_x)
                min_x = maybe_min_x;
            if (maybe_min_y < min_y)
                min_y = maybe_min_y;
            if (maybe_max_x > max_x)
                max_x = maybe_max_x;
            if (maybe_max_y > max_y)
                max_y = maybe_max_y;
        }
        // left down node
        rect[0] = min_x;
        rect[1] = min_y;
        // right top node
        rect[2] = max_x;
        rect[3] = max_y;
        return;
    }
}

static bool is_position_in_MBR(uint16_t x, uint16_t y, uint16_t rect[4])
{
    if (x >= rect[0] && x <= rect[2] && y >= rect[1] && y <= rect[3])
        return true;
    return false;
}

static bool is_MBR_intersect_MBR(uint16_t rect1[4], uint16_t rect2[4])
{
    if (rect1[2] >= rect2[0] && rect1[3] >= rect2[1] && rect1[0] <= rect2[2] && rect1[1] <= rect2[3])
        return true;
    return false;
}

static void extend_MBR_to_contain(uint16_t rect_ext[4], uint16_t rect_be_contain[4])
{
    if (rect_ext[0] > rect_be_contain[0])
        rect_ext[0] = rect_be_contain[0];
    if (rect_ext[1] > rect_be_contain[1])
        rect_ext[1] = rect_be_contain[1];
    if (rect_ext[2] < rect_be_contain[2])
        rect_ext[2] = rect_be_contain[2];
    if (rect_ext[3] < rect_be_contain[3])
        rect_ext[3] = rect_be_contain[3];
}

static struct node *tree_split_leaf_node(struct node *n)
{
    int m = n->count;
    uint32_t min_split_MBR_SUM = 65536;

    struct node *leaf1 = malloc(sizeof(struct node));
    memset(leaf1, 0, sizeof(struct node));
    struct node *leaf2 = malloc(sizeof(struct node));
    memset(leaf2, 0, sizeof(struct node));

    leaf1->ntype |= LEAF_BIT_MASK;
    leaf2->ntype |= LEAF_BIT_MASK;

    struct element *best_set1[B + 1] = {0};
    int best_set1num = 0;

    struct element *best_set2[B + 1] = {0};
    int best_set2num = 0;

    // X dimension
    tree_sort_leaf_node(n, true);
    for (int i = minB; i < m - minB; i++)
    {
        int set1num;
        int set2num;
        struct element *set1[B + 1] = {0};
        struct element *set2[B + 1] = {0};
        uint16_t rect1[4] = {0};
        uint16_t rect2[4] = {0};
        // first i points into set1
        for (set1num = 0; set1num < i; set1num++)
        {
            set1[set1num] = n->childs[set1num];
        }
        // other into set2
        for (set2num = 0; set2num < m - i; set2num++)
        {
            set2[set2num] = n->childs[i + set2num];
        }
        // assign to nodes calculate the sum of MBR
        leaf1->count = set1num;
        memcpy(leaf1->childs, set1, sizeof(void *) * (set1num));
        tree_derive_MBR_node(leaf1, rect1);

        leaf2->count = set2num;
        memcpy(leaf2->childs, set2, sizeof(void *) * (set2num));
        tree_derive_MBR_node(leaf2, rect2);

        uint32_t MBR_SUM = tree_get_MBR_perimeter(rect1) + tree_get_MBR_perimeter(rect2);
        if (MBR_SUM < min_split_MBR_SUM)
        {
            // better split
            min_split_MBR_SUM = MBR_SUM;
            best_set1num = set1num;
            best_set2num = set2num;
            memcpy(best_set1, set1, (B + 1) * sizeof(void *));
            memcpy(best_set2, set2, (B + 1) * sizeof(void *));
        }
    }

    // Y dimension
    tree_sort_leaf_node(n, false);
    for (int i = minB; i < m - minB; i++)
    {
        int set1num;
        int set2num;
        struct element *set1[B + 1] = {0};
        struct element *set2[B + 1] = {0};
        uint16_t rect1[4] = {0};
        uint16_t rect2[4] = {0};
        // first i points into set1
        for (set1num = 0; set1num < i; set1num++)
        {
            set1[set1num] = n->childs[set1num];
        }
        // other into set2
        for (set2num = 0; set2num < m - i; set2num++)
        {
            set2[set2num] = n->childs[i + set2num];
        }
        // assign to nodes calculate the sum of MBR
        leaf1->count = set1num;
        memcpy(leaf1->childs, set1, sizeof(void *) * (set1num));
        tree_derive_MBR_node(leaf1, rect1);

        leaf2->count = set2num;
        memcpy(leaf2->childs, set2, sizeof(void *) * (set2num));
        tree_derive_MBR_node(leaf2, rect2);

        uint32_t MBR_SUM = tree_get_MBR_perimeter(rect1) + tree_get_MBR_perimeter(rect2);
        if (MBR_SUM < min_split_MBR_SUM)
        {
            // better split
            min_split_MBR_SUM = MBR_SUM;
            best_set1num = set1num;
            best_set2num = set2num;
            memcpy(best_set1, set1, (B + 1) * sizeof(void *));
            memcpy(best_set2, set2, (B + 1) * sizeof(void *));
        }
    }

    // we should have one good split
    free(leaf1);
    free(leaf2);

    struct node *newleaf = malloc(sizeof(struct node));
    memset(newleaf, 0, sizeof(struct node));

    newleaf->ntype |= LEAF_BIT_MASK;
    // set1 to original node and set2 to new node
    n->count = best_set1num;
    memcpy(n->childs, best_set1, (B + 1) * (sizeof(void *)));
    // set2 to new leaf
    newleaf->count = best_set2num;
    memcpy(newleaf->childs, best_set2, (B + 1) * (sizeof(void *)));

    return newleaf;
}

static struct node *tree_split_internal_node(struct node *n)
{
    int m = n->count;
    uint32_t min_split_MBR_SUM = 65536;

    struct node *tmp1 = malloc(sizeof(struct node));
    memset(tmp1, 0, sizeof(struct node));
    struct node *tmp2 = malloc(sizeof(struct node));
    memset(tmp2, 0, sizeof(struct node));

    struct element *best_set1[B + 1] = {0};
    int best_set1num = 0;

    struct element *best_set2[B + 1] = {0};
    int best_set2num = 0;

    // X-dimension left boundary
    tree_sort_internal_node(n, true, true);
    for (int i = minB; i < m - minB; i++)
    {
        int set1num;
        int set2num;
        struct element *set1[B + 1] = {0};
        struct element *set2[B + 1] = {0};
        uint16_t rect1[4] = {0};
        uint16_t rect2[4] = {0};
        // first i points into set1
        for (set1num = 0; set1num < i; set1num++)
        {
            set1[set1num] = n->childs[set1num];
        }
        // other into set2
        for (set2num = 0; set2num < m - i; set2num++)
        {
            set2[set2num] = n->childs[i + set2num];
        }
        // assign to nodes calculate the sum of MBR
        tmp1->count = set1num;
        memcpy(tmp1->childs, set1, sizeof(void *) * (set1num));
        tree_derive_MBR_node(tmp1, rect1);

        tmp2->count = set2num;
        memcpy(tmp2->childs, set2, sizeof(void *) * (set2num));
        tree_derive_MBR_node(tmp2, rect2);

        uint32_t MBR_SUM = tree_get_MBR_perimeter(rect1) + tree_get_MBR_perimeter(rect2);
        if (MBR_SUM < min_split_MBR_SUM)
        {
            // better split
            min_split_MBR_SUM = MBR_SUM;
            best_set1num = set1num;
            best_set2num = set2num;
            memcpy(best_set1, set1, (B + 1) * sizeof(void *));
            memcpy(best_set2, set2, (B + 1) * sizeof(void *));
        }
    }
    // X-dimension right boundary
    tree_sort_internal_node(n, true, false);
    for (int i = minB; i < m - minB; i++)
    {
        int set1num;
        int set2num;
        struct element *set1[B + 1] = {0};
        struct element *set2[B + 1] = {0};
        uint16_t rect1[4] = {0};
        uint16_t rect2[4] = {0};
        // first i points into set1
        for (set1num = 0; set1num < i; set1num++)
        {
            set1[set1num] = n->childs[set1num];
        }
        // other into set2
        for (set2num = 0; set2num < m - i; set2num++)
        {
            set2[set2num] = n->childs[i + set2num];
        }
        // assign to nodes calculate the sum of MBR
        tmp1->count = set1num;
        memcpy(tmp1->childs, set1, sizeof(void *) * (set1num));
        tree_derive_MBR_node(tmp1, rect1);

        tmp2->count = set2num;
        memcpy(tmp2->childs, set2, sizeof(void *) * (set2num));
        tree_derive_MBR_node(tmp2, rect2);

        uint32_t MBR_SUM = tree_get_MBR_perimeter(rect1) + tree_get_MBR_perimeter(rect2);
        if (MBR_SUM < min_split_MBR_SUM)
        {
            // better split
            min_split_MBR_SUM = MBR_SUM;
            best_set1num = set1num;
            best_set2num = set2num;
            memcpy(best_set1, set1, (B + 1) * sizeof(void *));
            memcpy(best_set2, set2, (B + 1) * sizeof(void *));
        }
    }
    // Y-dimension down boundary
    tree_sort_internal_node(n, false, true);
    for (int i = minB; i < m - minB; i++)
    {
        int set1num;
        int set2num;
        struct element *set1[B + 1] = {0};
        struct element *set2[B + 1] = {0};
        uint16_t rect1[4] = {0};
        uint16_t rect2[4] = {0};
        // first i points into set1
        for (set1num = 0; set1num < i; set1num++)
        {
            set1[set1num] = n->childs[set1num];
        }
        // other into set2
        for (set2num = 0; set2num < m - i; set2num++)
        {
            set2[set2num] = n->childs[i + set2num];
        }
        // assign to nodes calculate the sum of MBR
        tmp1->count = set1num;
        memcpy(tmp1->childs, set1, sizeof(void *) * (set1num));
        tree_derive_MBR_node(tmp1, rect1);

        tmp2->count = set2num;
        memcpy(tmp2->childs, set2, sizeof(void *) * (set2num));
        tree_derive_MBR_node(tmp2, rect2);

        uint32_t MBR_SUM = tree_get_MBR_perimeter(rect1) + tree_get_MBR_perimeter(rect2);
        if (MBR_SUM < min_split_MBR_SUM)
        {
            // better split
            min_split_MBR_SUM = MBR_SUM;
            best_set1num = set1num;
            best_set2num = set2num;
            memcpy(best_set1, set1, (B + 1) * sizeof(void *));
            memcpy(best_set2, set2, (B + 1) * sizeof(void *));
        }
    }
    // Y-dimension top boundary
    for (int i = minB; i < m - minB; i++)
    {
        int set1num;
        int set2num;
        struct element *set1[B + 1] = {0};
        struct element *set2[B + 1] = {0};
        uint16_t rect1[4] = {0};
        uint16_t rect2[4] = {0};
        // first i points into set1
        for (set1num = 0; set1num < i; set1num++)
        {
            set1[set1num] = n->childs[set1num];
        }
        // other into set2
        for (set2num = 0; set2num < m - i; set2num++)
        {
            set2[set2num] = n->childs[i + set2num];
        }
        // assign to nodes calculate the sum of MBR
        tmp1->count = set1num;
        memcpy(tmp1->childs, set1, sizeof(void *) * (set1num));
        tree_derive_MBR_node(tmp1, rect1);

        tmp2->count = set2num;
        memcpy(tmp2->childs, set2, sizeof(void *) * (set2num));
        tree_derive_MBR_node(tmp2, rect2);

        uint32_t MBR_SUM = tree_get_MBR_perimeter(rect1) + tree_get_MBR_perimeter(rect2);
        if (MBR_SUM < min_split_MBR_SUM)
        {
            // better split
            min_split_MBR_SUM = MBR_SUM;
            best_set1num = set1num;
            best_set2num = set2num;
            memcpy(best_set1, set1, (B + 1) * sizeof(void *));
            memcpy(best_set2, set2, (B + 1) * sizeof(void *));
        }
    }

    // we should have one good split
    free(tmp1);
    free(tmp2);

    struct node *newnode = malloc(sizeof(struct node));
    memset(newnode, 0, sizeof(struct node));

    // set1 to original node and set2 to new node
    n->count = best_set1num;
    memcpy(n->childs, best_set1, (B + 1) * (sizeof(void *)));
    // set2 to new leaf
    newnode->count = best_set2num;
    memcpy(newnode->childs, best_set2, (B + 1) * (sizeof(void *)));

    // made a mistake here
    // new leaf's node need to re-parent
    for (int i = 0; i < newnode->count; i++)
    {
        struct node *new_n = newnode->childs[i];
        new_n->parent = newnode;
    }

    return newnode;
}

static struct node *tree_split_node(struct node *n)
{
    if (is_leaf(n))
    {
        return tree_split_leaf_node(n);
    }
    else
    {
        return tree_split_internal_node(n);
    }
}

static void tree_handle_node_overflow(struct node *n)
{
    // Find the "best" split
    struct node *another_n = tree_split_node(n);

    if (is_root(n))
    {
        // need a new root
        // the old node is not a root now
        n->ntype &= ~ROOT_BIT_MASK;
        struct node *newroot = malloc(sizeof(struct node));
        memset(newroot, 0, sizeof(struct node));
        newroot->ntype |= ROOT_BIT_MASK;
        newroot->count = 2;
        newroot->childs[0] = n;
        newroot->childs[1] = another_n;
        n->parent = newroot;
        another_n->parent = newroot;
        gtree->root = newroot;
        gtree->height += 1;
    }
    else
    {
        struct node *parent = n->parent;
        parent->childs[parent->count++] = another_n;
        another_n->parent = parent;
        if (parent->count == B + 1)
        {
            tree_handle_node_overflow(parent);
        }
    }
}

static void tree_handle_node_underflow(struct node *n)
{
    if (is_root(n))
    {
        if (is_leaf(n))
        {
            // do nothing
        }
        // may need to lower down the root
        else if (n->count == 1)
        {
            struct node *newroot = n->childs[0];
            newroot->ntype |= ROOT_BIT_MASK;
            newroot->parent = NULL;
            free(n);
            gtree->root = newroot;
            gtree->height -= 1;
        }
        return;
    }
    else
    {
        if (is_leaf(n))
        {
            // this node is going to be deleted
            // notice parent
            struct node *parent = n->parent;
            int childindex;
            for (childindex = 0; childindex < parent->count; childindex++)
            {
                if (parent->childs[childindex] == n)
                    break;
            }
            for (int i = childindex; i < parent->count - 1; i++)
            {
                parent->childs[i] = parent->childs[i + 1];
            }
            parent->childs[parent->count - 1] = NULL;
            parent->count -= 1;

            // reinsert all remain elements
            // through root is simple
            gtree->elem_count -= n->count;
            for (int i = 0; i < n->count; i++)
            {
                struct element *e = n->childs[i];
                tree_insert_node(gtree->root, e);
            }

            // this child is over, we need to decide
            // if its parent need to underflow
            free(n);
            if (parent->count < minB)
                tree_handle_node_underflow(parent);
        }
        else
        {
            struct node *parent = n->parent;
            int childindex;
            for (childindex = 0; childindex < parent->count; childindex++)
            {
                if (parent->childs[childindex] == n)
                    break;
            }
            for (int i = childindex; i < parent->count - 1; i++)
            {
                parent->childs[i] = parent->childs[i + 1];
            }
            parent->childs[parent->count - 1] = NULL;
            parent->count -= 1;

            // through parent to find neighbors
            // that is suitable to insert branch
            for (int k = 0; k < n->count; k++)
            {
                struct node *being_insert = n->childs[k];
                struct node *suppose_insert = tree_choose_branch(parent, being_insert);
                tree_insert_branch(suppose_insert, being_insert);
            }
            free(n);
            if (parent->count < minB)
                tree_handle_node_underflow(parent);
        }
    }
}

static struct element *tree_query_element(struct node *n, uint16_t wantx, uint16_t wanty)
{
    if (is_leaf(n))
    {
        // traverse childs to confirm
        for (int i = 0; i < n->count; i++)
        {
            struct element *eptr = n->childs[i];
            if (eptr->x == wantx && eptr->y == wanty)
                return eptr;
        }
        return NULL;
    }
    else
    {
        // traverse MBR of child to confirm
        for (size_t i = 0; i < n->count; i++)
        {
            struct node *nptr = n->childs[i];
            struct element *tmp = NULL;
            uint16_t rect[4] = {0};
            tree_derive_MBR_node(nptr, rect);
            if (is_position_in_MBR(wantx, wanty, rect))
            {
                tmp = tree_query_element(nptr, wantx, wanty);
                // we do this because there can be several intersecting MBR
                // and we believe there is only one supposed node
                // this implementation is buggy, maybe unintended solution here :X
                if (tmp)
                    return tmp;
            }
        }
        return NULL;
    }
}

static size_t tree_query_range(struct element *output[], size_t offset, struct node *n, uint16_t range[4])
{
    if (is_leaf(n))
    {
        // put all childs that in the range
        for (int i = 0; i < n->count; i++)
        {
            struct element *eptr = n->childs[i];
            if (is_position_in_MBR(eptr->x, eptr->y, range))
            {
                output[offset++] = eptr;
            }
        }
        return offset;
    }
    else
    {
        // traverse MBR of child to confirm
        for (size_t i = 0; i < n->count; i++)
        {
            struct node *nptr = n->childs[i];
            uint16_t rect[4] = {0};
            tree_derive_MBR_node(nptr, rect);
            if (is_MBR_intersect_MBR(rect, range))
            {
                offset = tree_query_range(output, offset, nptr, range);
            }
        }
        return offset;
    }
}

void prepare()
{
    setvbuf(stdin, 0LL, 2, 0LL);
    setvbuf(stdout, 0LL, 2, 0LL);
    setvbuf(stderr, 0LL, 2, 0LL);
    puts(banner);
    // alarm(120);
}

void choice_insert_handler()
{
    if (gtree->elem_count >= ELEM_COUNT_MAX)
    {
        printf("there are two many elements\n");
        return;
    }

    uint16_t x_location;
    uint16_t y_location;
    printf("new element x-coordinate value: ");
    scanf("%hu", &x_location);
    printf("new element y-coordinate value: ");
    scanf("%hu", &y_location);
    // check these coordinations
    if (x_location >= CORD_SIZE_MAX || y_location >= CORD_SIZE_MAX)
    {
        puts("invalid cordinations");
        return;
    }
    struct element *elem = malloc(sizeof(struct element));
    memset(elem, 0, sizeof(elem));
    elem->x = x_location;
    elem->y = y_location;
    printf("new element name: ");
    read_buf_wrap(elem->name, NODE_NAME_MAX);
    // node is prepared, conduct insertion
    tree_insert_node(gtree->root, elem);
}

void choice_delete_handler()
{
    uint16_t x_location;
    uint16_t y_location;
    printf("want element x-coordinate value: ");
    scanf("%hu", &x_location);
    printf("want element y-coordinate value: ");
    scanf("%hu", &y_location);
    // check these coordinations
    if (x_location >= CORD_SIZE_MAX || y_location >= CORD_SIZE_MAX)
    {
        puts("invalid cordinations");
        return;
    }
    struct element *e = tree_query_element(gtree->root, x_location, y_location);
    if (!e)
    {
        printf("such node does not exists\n");
        return;
    }

    // do removal
    tree_delete_elem(gtree->root, e);
    printf("done\n");
}

void choice_edit_handler()
{
    uint16_t x_location;
    uint16_t y_location;
    printf("want element x-coordinate value: ");
    scanf("%hu", &x_location);
    printf("want element y-coordinate value: ");
    scanf("%hu", &y_location);
    // check these coordinations
    if (x_location >= CORD_SIZE_MAX || y_location >= CORD_SIZE_MAX)
    {
        puts("invalid cordinations");
        return;
    }
    struct element *e = tree_query_element(gtree->root, x_location, y_location);
    if (!e)
    {
        printf("such node does not exists\n");
        return;
    }

    char namebuf[NODE_NAME_MAX] = {0};
    printf("input the edited name: ");
    read_buf_wrap(namebuf, NODE_NAME_MAX);
    memcpy(e->name, namebuf, NODE_NAME_MAX);
    printf("done\n");
}

void choice_show_handler()
{
    uint16_t x_location;
    uint16_t y_location;
    printf("want element x-coordinate value: ");
    scanf("%hu", &x_location);
    printf("want element y-coordinate value: ");
    scanf("%hu", &y_location);
    // check these coordinations
    if (x_location >= CORD_SIZE_MAX || y_location >= CORD_SIZE_MAX)
    {
        puts("invalid cordinations");
        return;
    }
    struct element *e = tree_query_element(gtree->root, x_location, y_location);
    if (!e)
    {
        printf("such node does not exists\n");
        return;
    }
    printf("found!!! its name: ");
    write_buf_wrap(e->name, NODE_NAME_MAX);
    printf("\n");
    return;
}

void choice_query_handler()
{
    uint16_t x1_location;
    uint16_t y1_location;
    uint16_t x2_location;
    uint16_t y2_location;
    printf("left-down position x-coordinate value: ");
    scanf("%hu", &x1_location);
    printf("left-down position y-coordinate value: ");
    scanf("%hu", &y1_location);
    printf("right-up position x-coordinate value: ");
    scanf("%hu", &x2_location);
    printf("right-up position y-coordinate value: ");
    scanf("%hu", &y2_location);

    struct element *stackbuf[ELEM_COUNT_MAX] = {0};
    size_t elemcount = 0;
    elemcount = tree_query_range(stackbuf, elemcount, gtree->root, (uint16_t[]){x1_location, y1_location, x2_location, y2_location});
    printf("find totally %lu elements\n", elemcount);
    for (size_t i = 0; i < elemcount; i++)
    {
        struct element *e = stackbuf[i];
        printf("%lu-th name: ", i);
        write_buf_wrap(e->name, NODE_NAME_MAX);
        printf("\n");
    }
    return;
}

int main(int argc, char *argv[])
{
    prepare();

    tree_init();

    while (true)
    {
        int choice;

        printf("%s", menu);
        scanf("%d", &choice);

        switch (choice)
        {
        case INSERT:
            choice_insert_handler();
            break;

        case DELETE:
            choice_delete_handler();
            break;

        case EDIT:
            choice_edit_handler();
            break;

        case SHOW:
            choice_show_handler();
            break;

        case QUERY:
            choice_query_handler();
            break;

        case LEAVE:
            goto leave;
            break;

        default:
            puts("That's not a valid action");
            break;
        }
    }

leave:
    tree_clear();
}
