#include <linux/miscdevice.h>
#include <linux/fs.h>
#include <linux/kernel.h>
#include <linux/module.h>

#include <linux/ioctl.h>
#include <linux/timer.h>
#include <linux/workqueue.h>
#include <linux/types.h>
#include <linux/crypto.h>
#include <linux/string.h>
#include <linux/slab.h>
#include <linux/mutex.h>
#include <linux/spinlock.h>

#include <linux/scatterlist.h>
#include <crypto/internal/cipher.h>

// else failed to compile
MODULE_IMPORT_NS(CRYPTO_INTERNAL);

// #define DEBUG

/* ioctl commands */
#define KKK_IOCTL_ADD _IO('k', 100)
#define KKK_IOCTL_UPDATE _IO('k', 103)
#define KKK_IOCTL_DUMP _IO('k', 105)
#define KKK_IOCTL_LAUNCH _IO('k', 107)
#define KKK_IOCTL_DETACH _IO('k', 109)

#define MAX_OBJECT_NUM (16)

enum kkk_type
{
    KKK_CRYPTO_DES,
    KKK_CRYPTO_3DES,
    KKK_CRYPTO_AES128,
    KKK_CRYPTO_AES256,
    KKK_CRYPTO_NUM
};

/* core data strcutres */
struct kkk_pack
{
    unsigned int size;
    void *ptr; // user space pointer
};

struct kkk_obj
{
    struct kkk_pack keypack;
    struct kkk_pack datapack;
    int id;
    int enc;
    int (*handler)(struct kkk_obj *);
};

struct kkk_desc
{
    spinlock_t desc_lock;
    struct kkk_obj *objects[MAX_OBJECT_NUM];
};

/* interface structures */

struct kkk_ioctl_add_arg
{
    enum kkk_type type;
    int enc;
    struct kkk_pack key;
    struct kkk_pack data;
};

struct kkk_ioctl_other_arg
{
    int id;
    struct kkk_pack key;
    struct kkk_pack data;
};

// struct kkk_ioctl_dump_arg
// {
//     int id;
//     void* keyptr;
//     void* dataptr;
// };

// simply uses integer
// struct kkk_ioctl_launch_arg
// {
//     int id;
// };

// struct kkk_ioctl_detach_arg
// {
//     int id;
// };

static void
enc_dec_internal(struct crypto_cipher *tfm, char *buf, size_t size,
                 char *block1, char *block2, size_t blocksize, int enc)
{
    int i;
    for (i = 0; i < size; i += blocksize)
    {
        memcpy(block1, buf + i, blocksize);
        /* code */
        if (enc)
        {
            crypto_cipher_encrypt_one(tfm, block2, block1);
        }
        else
        {
            crypto_cipher_decrypt_one(tfm, block2, block1);
        }
        memcpy(buf + i, block2, blocksize);
    }
}

#define DES_KEY_SIZE (8)
#define DES_BLOCK_SIZE (8)
static int kkk_des_cb(struct kkk_obj *obj)
{
    struct crypto_cipher *tfm;
    int ret = 0;
    unsigned char key[DES_KEY_SIZE] = {0};
    unsigned char block1[DES_BLOCK_SIZE] = {0};
    unsigned char block2[DES_BLOCK_SIZE] = {0};

#ifdef DEBUG
    pr_info("kkk_des_cb() prologue, keysize = %d, datasize = %d\n", obj->keypack.size, obj->datapack.size);
#endif

    // santiy check
    if (obj->keypack.size < DES_KEY_SIZE || obj->datapack.size < DES_BLOCK_SIZE)
    {
        pr_err("bad size\n");
        ret = -EINVAL;
        goto out;
    }

    memcpy(key, obj->keypack.ptr, DES_KEY_SIZE);

    tfm = crypto_alloc_cipher("des", 0, 0);
    if (IS_ERR(tfm))
    {
        pr_err("des cipher cannot be loaded\n");
        ret = PTR_ERR(tfm);
        goto out;
    }
    ret = crypto_cipher_setkey(tfm, key, DES_KEY_SIZE);
    if (ret)
    {
        pr_err("des setkey failed\n");
        goto free;
    }

    enc_dec_internal(tfm, obj->datapack.ptr, obj->datapack.size, block1, block2, DES_BLOCK_SIZE, obj->enc);

free:
    crypto_free_cipher(tfm);
out:
    return ret;
}

#define TDES_KEY_SIZE (24)
#define TDES_BLOCK_SIZE (8)
static int kkk_tdes_cb(struct kkk_obj *obj)
{
    struct crypto_cipher *tfm;
    int ret = 0;
    unsigned char key[TDES_KEY_SIZE] = {0};
    unsigned char block1[TDES_BLOCK_SIZE] = {0};
    unsigned char block2[TDES_BLOCK_SIZE] = {0};

#ifdef DEBUG
    pr_info("kkk_tdes_cb() prologue, keysize = %d, datasize = %d\n", obj->keypack.size, obj->datapack.size);
#endif

    // santiy check
    if (obj->keypack.size < TDES_KEY_SIZE || obj->datapack.size < TDES_BLOCK_SIZE)
    {
        pr_err("bad size\n");
        ret = -EINVAL;
        goto out;
    }

    memcpy(key, obj->keypack.ptr, TDES_KEY_SIZE);

    tfm = crypto_alloc_cipher("des3_ede", 0, 0);
    if (IS_ERR(tfm))
    {
        pr_err("des3ede cipher cannot be loaded\n");
        ret = PTR_ERR(tfm);
        goto out;
    }
    ret = crypto_cipher_setkey(tfm, key, TDES_KEY_SIZE);
    if (ret)
    {
        pr_err("des3ede setkey failed\n");
        goto free;
    }

    enc_dec_internal(tfm, obj->datapack.ptr, obj->datapack.size, block1, block2, TDES_BLOCK_SIZE, obj->enc);

free:
    crypto_free_cipher(tfm);
out:
    return ret;
}

#define AES128_KEY_SIZE (16)
#define AES128_BLOCK_SIZE (16)
static int kkk_aes128_cb(struct kkk_obj *obj)
{
    struct crypto_cipher *tfm;
    int ret = 0;
    unsigned char key[AES128_KEY_SIZE] = {0};
    unsigned char block1[AES128_BLOCK_SIZE] = {0};
    unsigned char block2[AES128_BLOCK_SIZE] = {0};

#ifdef DEBUG
    pr_info("kkk_aes128_cb() prologue, keysize = %d, datasize = %d\n", obj->keypack.size, obj->datapack.size);
#endif

    // santiy check
    if (obj->keypack.size < AES128_KEY_SIZE || obj->datapack.size < AES128_BLOCK_SIZE)
    {
        pr_err("bad size\n");
        ret = -EINVAL;
        goto out;
    }

    memcpy(key, obj->keypack.ptr, AES128_KEY_SIZE);

    tfm = crypto_alloc_cipher("aes", 0, 0);
    if (IS_ERR(tfm))
    {
        pr_err("aes128 cipher cannot be loaded\n");
        ret = PTR_ERR(tfm);
        goto out;
    }
    ret = crypto_cipher_setkey(tfm, key, AES128_KEY_SIZE);
    if (ret)
    {
        pr_err("aes128 setkey failed\n");
        goto free;
    }

    enc_dec_internal(tfm, obj->datapack.ptr, obj->datapack.size, block1, block2, AES128_BLOCK_SIZE, obj->enc);

free:
    crypto_free_cipher(tfm);
out:
    return ret;
}

#define AES256_KEY_SIZE (32)
#define AES256_BLOCK_SIZE (16)
static int kkk_aes256_cb(struct kkk_obj *obj)
{
    struct crypto_cipher *tfm;
    int ret = 0;
    unsigned char key[AES256_KEY_SIZE] = {0};
    unsigned char block1[AES256_BLOCK_SIZE] = {0};
    unsigned char block2[AES256_BLOCK_SIZE] = {0};

#ifdef DEBUG
    pr_info("kkk_aes256_cb() prologue, keysize = %d, datasize = %d\n", obj->keypack.size, obj->datapack.size);
#endif

    // santiy check
    if (obj->keypack.size < AES256_KEY_SIZE || obj->datapack.size < AES256_BLOCK_SIZE)
    {
        pr_err("bad size\n");
        ret = -EINVAL;
        goto out;
    }

    memcpy(key, obj->keypack.ptr, AES256_KEY_SIZE);

    tfm = crypto_alloc_cipher("aes", 0, 0);
    if (IS_ERR(tfm))
    {
        pr_err("aes256 cipher cannot be loaded\n");
        ret = PTR_ERR(tfm);
        goto out;
    }
    ret = crypto_cipher_setkey(tfm, key, AES256_KEY_SIZE);
    if (ret)
    {
        pr_err("aes256 setkey failed\n");
        goto free;
    }

    enc_dec_internal(tfm, obj->datapack.ptr, obj->datapack.size, block1, block2, AES256_BLOCK_SIZE, obj->enc);

free:
    crypto_free_cipher(tfm);
out:
    return ret;
}

int (*handlers[])(struct kkk_obj *) = {kkk_des_cb, kkk_tdes_cb, kkk_aes128_cb, kkk_aes256_cb};

/* empty handler, we just need ioctl */
static int
kkk_open(struct inode *inodep, struct file *filp)
{
    struct kkk_desc *desc = kzalloc(sizeof(struct kkk_desc), GFP_KERNEL);
    if (!desc)
        return -ENOMEM;

    filp->private_data = desc;

    return 0;
}

static int kkk_close(struct inode *inodep, struct file *filp)
{
    int i;
    struct kkk_obj *obj;
    struct kkk_desc *desc = filp->private_data;

    for (i = 0; i < MAX_OBJECT_NUM; i++)
    {
        obj = desc->objects[i];
        if (obj)
        {
            kfree(obj);
            desc->objects[i] = NULL;
        }
    }
    kfree(desc);
    return 0;
}

static ssize_t kkk_write(struct file *file, const char __user *buf,
                         size_t len, loff_t *ppos)
{
    return len;
}

static ssize_t kkk_read(struct file *file, char __user *buf,
                        size_t len, loff_t *ppos)
{
    return len;
}

/* core utilites */
static long kkk_internal_ioctl(struct file *filp, unsigned int cmd, unsigned long value)
{
    int ret = 0;
    int r;
    int i;
    int id;
    struct kkk_ioctl_other_arg other_arg;
    struct kkk_ioctl_add_arg add_arg;
    struct kkk_obj *obj;
    struct kkk_desc *desc;

    desc = filp->private_data;

    spin_lock(&desc->desc_lock);

    switch (cmd)
    {
    case KKK_IOCTL_ADD:
    {
        // get argument
        r = copy_from_user(&add_arg, (void *)value, sizeof(add_arg));
        if (r)
        {
            ret = -EINVAL;
            goto out;
        }
        // find id first
        id = -1;
        for (i = 0; i < MAX_OBJECT_NUM; i++)
        {
            if (!desc->objects[i])
            {
                id = i;
                break;
            }
        }
        if (id == -1)
        {
            ret = -EINVAL;
            goto out;
        }
        obj = kzalloc(sizeof(struct kkk_obj) + add_arg.data.size + add_arg.key.size, GFP_KERNEL);
        if (!obj)
        {
            ret = -ENOMEM;
            goto out;
        }
#ifdef DEBUG
        pr_info("%d-th id object at 0x%lx, size: %ld", id, (unsigned long)obj, sizeof(struct kkk_obj) + add_arg.data.size + add_arg.key.size);
#endif
        // fill in information
        desc->objects[id] = obj;
        obj->id = id;
        obj->enc = add_arg.enc;
        obj->handler = handlers[add_arg.type % KKK_CRYPTO_NUM];
        obj->keypack.size = add_arg.key.size;
        obj->keypack.ptr = (char *)obj + sizeof(struct kkk_obj);
        obj->datapack.size = add_arg.data.size;
        obj->datapack.ptr = (char *)obj + sizeof(struct kkk_obj) + add_arg.key.size;
        // copy information
        r = copy_from_user(obj->keypack.ptr, add_arg.key.ptr, obj->keypack.size);
        r = copy_from_user(obj->datapack.ptr, add_arg.data.ptr, obj->datapack.size);
        if (r)
        {
            desc->objects[id] = NULL;
            kfree(obj);
            ret = -EINVAL;
        }
        break;
    }
    case KKK_IOCTL_UPDATE:
    {
        // get argument
        r = copy_from_user(&other_arg, (void *)value, sizeof(other_arg));
        if (r)
        {
            ret = -EINVAL;
            goto out;
        }
        id = other_arg.id;
        if (id < 0 || id >= MAX_OBJECT_NUM)
        {
            ret = -EINVAL;
            goto out;
        }
        obj = desc->objects[id];
        if (!obj)
        {
            ret = -EINVAL;
            goto out;
        }
        r = copy_from_user(obj->keypack.ptr, other_arg.key.ptr, obj->keypack.size);
        r = copy_from_user(obj->datapack.ptr, other_arg.data.ptr, obj->datapack.size);
        if (r)
        {
            ret = -EINVAL;
            goto out;
        }
        break;
    }
    case KKK_IOCTL_DUMP:
    {
        // get argument
        r = copy_from_user(&other_arg, (void *)value, sizeof(other_arg));
        if (r)
        {
            ret = -EINVAL;
            goto out;
        }
        id = other_arg.id;
        if (id < 0 || id >= MAX_OBJECT_NUM)
        {
            ret = -EINVAL;
            goto out;
        }
        obj = desc->objects[id];
        if (!obj)
        {
            ret = -EINVAL;
            goto out;
        }
#ifdef DEBUG
        pr_info("KKK_IOCTL_DUMP, key size: 0x%x, data size: 0x%x\n", obj->keypack.size, obj->datapack.size);
#endif
        r = copy_to_user(other_arg.key.ptr, obj->keypack.ptr, obj->keypack.size);
        r = copy_to_user(other_arg.data.ptr, obj->datapack.ptr, obj->datapack.size);
        if (r)
        {
            ret = -EINVAL;
            goto out;
        }
        break;
    }
    case KKK_IOCTL_LAUNCH:
    {
        // get argument
        r = copy_from_user(&other_arg, (void *)value, sizeof(other_arg));
        if (r)
        {
            ret = -EINVAL;
            goto out;
        }
        id = other_arg.id;
        if (id < 0 || id >= MAX_OBJECT_NUM)
        {
            ret = -EINVAL;
            goto out;
        }
        obj = desc->objects[id];
        if (!obj)
        {
            ret = -EINVAL;
            goto out;
        }
        ret = obj->handler(obj);
        break;
    }
    case KKK_IOCTL_DETACH:
    {
        // get argument
        r = copy_from_user(&other_arg, (void *)value, sizeof(other_arg));
        if (r)
        {
            ret = -EINVAL;
            goto out;
        }
        id = other_arg.id;
        if (id < 0 || id >= MAX_OBJECT_NUM)
        {
            ret = -EINVAL;
            goto out;
        }
        obj = desc->objects[id];
        if (!obj)
        {
            ret = -EINVAL;
            goto out;
        }
        desc->objects[id] = NULL;
        kfree(obj);
        break;
    }
    default:
        ret = -EINVAL;
        break;
    }
out:
    spin_unlock(&desc->desc_lock);
    return ret;
}

static long kkk_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long value)
{
    return kkk_internal_ioctl(file, cmd, value);
}

static long kkk_compat_ioctl(struct file *file, unsigned int cmd, unsigned long value)
{
    return kkk_internal_ioctl(file, cmd, value);
}

static const struct file_operations kkk_fops = {
    .owner = THIS_MODULE,
    .write = kkk_write,
    .read = kkk_read,
    .open = kkk_open,
    .release = kkk_close,
    .unlocked_ioctl = kkk_unlocked_ioctl,
    .compat_ioctl = kkk_compat_ioctl,
    .llseek = no_llseek
};

struct miscdevice kkk_device = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = "kkk",
    .fops = &kkk_fops,
};

static int __init kkk_init(void)
{
    int error;

    error = misc_register(&kkk_device);
    if (error)
    {
        pr_err("misc_register fail\n");
        return error;
    }

    return 0;
}

static void __exit kkk_exit(void)
{
    misc_deregister(&kkk_device);
}

module_init(kkk_init);
module_exit(kkk_exit);

MODULE_DESCRIPTION("kkk vulnerable dirver");
MODULE_AUTHOR("f0rm2l1n");
MODULE_LICENSE("GPL");
