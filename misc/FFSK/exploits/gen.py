from ast import Str
from tqdm import tqdm
import math
import struct
import wave
import random
def gens(message):
	retStr = ""
	for char in message:
		print(bin(ord(char)).replace('0b','')[::-1])
		retStr += "0" + ('{0:08b}'.format(ord(char)))[::-1] + "1"
	print(retStr)
	return retStr

def manchester(message):
	retStr = ""
	for char in message:
		retStr += "01" if char=='1' else "10"
	return retStr
def manchesterInv(message):
	retStr = ""
	for ind in range(0, len(message), 2):
		char = message[ind]
		retStr += "0" if char=='1' else "1"
	return retStr

def HammingBolck(message):
	# if not len(message)==15:
	# 	print(message)
	assert(len(message)==15)
	message=message[::-1]
	code = 0
	m_pos = 0
	for ind in range(20):
		if (ind+1)&(ind): # Not parity check bit
			if int(message[m_pos],2):
				code = code ^ (1<<ind)
				code = code ^ (((ind+1)&0b1)<<(1-1))
				code = code ^ (((ind+1)&0b10)<<(2-2))
				code = code ^ (((ind+1)&0b100)<<(4-3))
				code = code ^ (((ind+1)&0b1000)<<(8-4))
				code = code ^ (((ind+1)&0b10000)<<(16-5))
			m_pos = m_pos + 1

	code = code ^ (1<<random.randint(0,19))

	retStr = "{0:020b}".format(code)
	print("from "+message[::-1]+" to "+retStr)
	
	return retStr

def HammingBolckInv(message):
	assert(len(message)==20)
	code = int(message,2)
	wrong = 0
	for ind in range(20):
		if (1<<ind)&code:
			wrong = wrong ^ (ind+1)
	if wrong:
		code = code ^ (1<<(wrong-1))
	print("wrong:"+str(wrong))
	retStr = ""
	for ind in range(20):
		if (ind+1)&(ind): # Not parity check bit
			retStr = retStr + ("1" if code&(1<<ind) else "0")
	# print("recover"+retStr)
	return retStr[::-1]

def Hamming(message):
	retStr = ""
	assert(len(message)%15==0)
	for ind in range(0,len(message),15):
		retStr = retStr + HammingBolck(message[ind:ind+15])
		if not HammingBolckInv(HammingBolck(message[ind:ind+15]))==message[ind:ind+15]:
			print(message[ind:ind+15])
		assert(HammingBolckInv(HammingBolck(message[ind:ind+15]))==message[ind:ind+15])
	return retStr

def HammingInv(message):
	retStr = ""
	assert(len(message)%20==0)
	for ind in range(0,len(message),20):
		retStr = retStr + HammingBolckInv(message[ind:ind+20])
	return retStr

def sinewave(sampleRate: int):
	s1 = gens('Sender:HINT_Hamming@ddddPdddddddPdddPdPP(20).ECCode; Content: Why do you use such a slow method with a high Bit Error Ratio for communication? It took me a lot of effort to correct bit-flips, making sure the communication was less error-prone...that is 2 say, THE ORIGINAL PROTOCOL IS WRAPPED BY SOME OTHER TRANSFORMATIONS! Fortunately, we can now communicate properly on another channel while enjoying a vacation in this BIG CITY--I mean, IEEE 802.3.....Wait, what is the new protocol? Guess by yourself!')

	s2 = gens(' data:image/png;base64,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')# !lenth%3 == 0
	assert(s2==HammingInv(Hamming(s2)))
	s2=Hamming(s2)
	assert(s2==manchesterInv(manchester(s2)))
	s2=manchester(s2)
	omega2025 = 2*math.pi/(sampleRate/2025)
	omega2225 = 2*math.pi/(sampleRate/2225)
	omega1070 = 2*math.pi/(sampleRate/1070)
	omega1270 = 2*math.pi/(sampleRate/1270)
	n=0
	t=0
	for ind in tqdm(range(max(len(s1),len(s2)))):
		for _ in range(160):
			if ind < len(s1):
				ch1 = s1[ind]
			else:
				ch1 = '0'

			if ind < len(s2):
				ch2 = s2[ind]
			else:
				ch2 = '0'
			yield int(5000*math.sin((omega2025 if ch1=='0' else omega2225)*t))\
			+int(5000*math.sin((omega1070 if ch2=='0' else omega1270)*t))
			t=t+1
		n=n+1

def generateSineWaveFile(file: Str, sampleRate: int):
	with wave.open(file, 'wb') as wf:
		wf.setnchannels(1)
		wf.setsampwidth(2)
		wf.setframerate(sampleRate)
		for s in sinewave(sampleRate):
			data = struct.pack('<h', int(s))
			wf.writeframes(data)

if __name__ == "__main__":
	
	filename = 'aaa.wav'

	generateSineWaveFile(filename, 48000)